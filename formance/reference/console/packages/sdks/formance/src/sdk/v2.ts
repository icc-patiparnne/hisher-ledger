/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeJSONQuery as encodeJSONQuery$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity } from "../lib/security.js";
import * as components from "../models/components/index.js";
import * as errors from "../models/errors/index.js";
import * as operations from "../models/operations/index.js";

export class V2 extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * List ledgers
     */
    async listLedgers(
        request: operations.V2ListLedgersRequest,
        options?: RequestOptions
    ): Promise<operations.V2ListLedgersResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ListLedgersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/ledger/v2")();

        const query$ = encodeFormQuery$({
            cursor: payload$.cursor,
            pageSize: payload$.pageSize,
            sort: payload$.sort,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListLedgers",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListLedgersResponse>()
            .json(200, operations.V2ListLedgersResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListLedgersResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a ledger
     */
    async getLedger(
        request: operations.V2GetLedgerRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetLedgerResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetLedgerRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetLedger",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetLedgerResponse>()
            .json(200, operations.V2GetLedgerResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetLedgerResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create a ledger
     */
    async createLedger(
        request: operations.V2CreateLedgerRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CreateLedgerRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V2CreateLedgerRequest, { explode: true });

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CreateLedger",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Update ledger metadata
     */
    async updateLedgerMetadata(
        request: operations.V2UpdateLedgerMetadataRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2UpdateLedgerMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/metadata")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2UpdateLedgerMetadata",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail("4XX")
            .json("5XX", errors.V2ErrorResponse$inboundSchema, { err: true })
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete ledger metadata by key
     */
    async deleteLedgerMetadata(
        request: operations.V2DeleteLedgerMetadataRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2DeleteLedgerMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            key: encodeSimple$("key", payload$.key, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/metadata/{key}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2DeleteLedgerMetadata",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Get information about a ledger
     */
    async getLedgerInfo(
        request: operations.V2GetLedgerInfoRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetLedgerInfoResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetLedgerInfoRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/_info")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetLedgerInfo",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetLedgerInfoResponse>()
            .json(200, operations.V2GetLedgerInfoResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetLedgerInfoResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Bulk request
     */
    async createBulk(
        request: operations.V2CreateBulkRequest,
        options?: RequestOptions
    ): Promise<operations.V2CreateBulkResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CreateBulkRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/_bulk")(pathParams$);

        const query$ = encodeFormQuery$({
            atomic: payload$.atomic,
            continueOnFailure: payload$.continueOnFailure,
            parallel: payload$.parallel,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CreateBulk",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.V2CreateBulkResponse>()
            .json(200, operations.V2CreateBulkResponse$inboundSchema)
            .json(400, errors.V2BulkResponse$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CreateBulkResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Count the accounts from a ledger
     */
    async countAccounts(
        request: operations.V2CountAccountsRequest,
        options?: RequestOptions
    ): Promise<operations.V2CountAccountsResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CountAccountsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/accounts")(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                pit: payload$.pit,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CountAccounts",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "HEAD",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.V2CountAccountsResponse | undefined>()
            .void(204, operations.V2CountAccountsResponse$inboundSchema.optional(), { hdrs: true })
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CountAccountsResponse$inboundSchema.optional(), {
                key: "Result",
            })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List accounts from a ledger
     *
     * @remarks
     * List accounts from a ledger, sorted by address in descending order.
     */
    async listAccounts(
        request: operations.V2ListAccountsRequest,
        options?: RequestOptions
    ): Promise<operations.V2ListAccountsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ListAccountsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/accounts")(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                expand: payload$.expand,
                pageSize: payload$.pageSize,
                pit: payload$.pit,
                sort: payload$.sort,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListAccounts",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListAccountsResponse>()
            .json(200, operations.V2ListAccountsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListAccountsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get account by its address
     */
    async getAccount(
        request: operations.V2GetAccountRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetAccountRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            address: encodeSimple$("address", payload$.address, {
                explode: false,
                charEncoding: "percent",
            }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/accounts/{address}")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            expand: payload$.expand,
            pit: payload$.pit,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetAccount",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetAccountResponse>()
            .json(200, operations.V2GetAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Add metadata to an account
     */
    async addMetadataToAccount(
        request: operations.V2AddMetadataToAccountRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2AddMetadataToAccountRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            address: encodeSimple$("address", payload$.address, {
                explode: false,
                charEncoding: "percent",
            }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/accounts/{address}/metadata"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            dryRun: payload$.dryRun,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "Idempotency-Key": encodeSimple$("Idempotency-Key", payload$["Idempotency-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2AddMetadataToAccount",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Delete metadata by key
     *
     * @remarks
     * Delete metadata by key
     */
    async deleteAccountMetadata(
        request: operations.V2DeleteAccountMetadataRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2DeleteAccountMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            address: encodeSimple$("address", payload$.address, {
                explode: false,
                charEncoding: "percent",
            }),
            key: encodeSimple$("key", payload$.key, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/accounts/{address}/metadata/{key}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "Idempotency-Key": encodeSimple$("Idempotency-Key", payload$["Idempotency-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2DeleteAccountMetadata",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Get statistics from a ledger
     *
     * @remarks
     * Get statistics from a ledger. (aggregate metrics on accounts and transactions)
     *
     */
    async readStats(
        request: operations.V2ReadStatsRequest,
        options?: RequestOptions
    ): Promise<operations.V2ReadStatsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ReadStatsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/stats")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ReadStats",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ReadStatsResponse>()
            .json(200, operations.V2ReadStatsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ReadStatsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Count the transactions from a ledger
     */
    async countTransactions(
        request: operations.V2CountTransactionsRequest,
        options?: RequestOptions
    ): Promise<operations.V2CountTransactionsResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CountTransactionsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/transactions")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeFormQuery$({
                pit: payload$.pit,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CountTransactions",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "HEAD",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.V2CountTransactionsResponse | undefined>()
            .void(204, operations.V2CountTransactionsResponse$inboundSchema.optional(), {
                hdrs: true,
            })
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CountTransactionsResponse$inboundSchema.optional(), {
                key: "Result",
            })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List transactions from a ledger
     *
     * @remarks
     * List transactions from a ledger, sorted by id in descending order.
     */
    async listTransactions(
        request: operations.V2ListTransactionsRequest,
        options?: RequestOptions
    ): Promise<operations.V2ListTransactionsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ListTransactionsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/transactions")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                expand: payload$.expand,
                order: payload$.order,
                pageSize: payload$.pageSize,
                pit: payload$.pit,
                reverse: payload$.reverse,
                sort: payload$.sort,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListTransactions",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListTransactionsResponse>()
            .json(200, operations.V2ListTransactionsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListTransactionsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create a new transaction to a ledger
     */
    async createTransaction(
        request: operations.V2CreateTransactionRequest,
        options?: RequestOptions
    ): Promise<operations.V2CreateTransactionResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CreateTransactionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V2PostTransaction, { explode: true });

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/transactions")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            dryRun: payload$.dryRun,
            force: payload$.force,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "Idempotency-Key": encodeSimple$("Idempotency-Key", payload$["Idempotency-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CreateTransaction",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2CreateTransactionResponse>()
            .json(200, operations.V2CreateTransactionResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CreateTransactionResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get transaction from a ledger by its ID
     */
    async getTransaction(
        request: operations.V2GetTransactionRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetTransactionResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetTransactionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/transactions/{id}")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            expand: payload$.expand,
            pit: payload$.pit,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetTransaction",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetTransactionResponse>()
            .json(200, operations.V2GetTransactionResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetTransactionResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Set the metadata of a transaction by its ID
     */
    async addMetadataOnTransaction(
        request: operations.V2AddMetadataOnTransactionRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2AddMetadataOnTransactionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/transactions/{id}/metadata"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            dryRun: payload$.dryRun,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "Idempotency-Key": encodeSimple$("Idempotency-Key", payload$["Idempotency-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2AddMetadataOnTransaction",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Delete metadata by key
     *
     * @remarks
     * Delete metadata by key
     */
    async deleteTransactionMetadata(
        request: operations.V2DeleteTransactionMetadataRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2DeleteTransactionMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            key: encodeSimple$("key", payload$.key, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/transactions/{id}/metadata/{key}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "Idempotency-Key": encodeSimple$("Idempotency-Key", payload$["Idempotency-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2DeleteTransactionMetadata",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Revert a ledger transaction by its ID
     */
    async revertTransaction(
        request: operations.V2RevertTransactionRequest,
        options?: RequestOptions
    ): Promise<operations.V2RevertTransactionResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2RevertTransactionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V2RevertTransactionRequest, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/transactions/{id}/revert")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            atEffectiveDate: payload$.atEffectiveDate,
            dryRun: payload$.dryRun,
            force: payload$.force,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2RevertTransaction",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2RevertTransactionResponse>()
            .json(201, operations.V2RevertTransactionResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2RevertTransactionResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get the aggregated balances from selected accounts
     */
    async getBalancesAggregated(
        request: operations.V2GetBalancesAggregatedRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetBalancesAggregatedResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetBalancesAggregatedRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/aggregate/balances")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeFormQuery$({
                pit: payload$.pit,
                useInsertionDate: payload$.useInsertionDate,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetBalancesAggregated",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetBalancesAggregatedResponse>()
            .json(200, operations.V2GetBalancesAggregatedResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetBalancesAggregatedResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get list of volumes with balances for (account/asset)
     */
    async getVolumesWithBalances(
        request: operations.V2GetVolumesWithBalancesRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetVolumesWithBalancesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetVolumesWithBalancesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/volumes")(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                endTime: payload$.endTime,
                groupBy: payload$.groupBy,
                insertionDate: payload$.insertionDate,
                pageSize: payload$.pageSize,
                sort: payload$.sort,
                startTime: payload$.startTime,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetVolumesWithBalances",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetVolumesWithBalancesResponse>()
            .json(200, operations.V2GetVolumesWithBalancesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetVolumesWithBalancesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List the logs from a ledger
     *
     * @remarks
     * List the logs from a ledger, sorted by ID in descending order.
     */
    async listLogs(
        request: operations.V2ListLogsRequest,
        options?: RequestOptions
    ): Promise<operations.V2ListLogsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ListLogsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/logs")(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
                pit: payload$.pit,
                sort: payload$.sort,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListLogs",
            oAuth2Scopes: ["auth:read", "ledger:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListLogsResponse>()
            .json(200, operations.V2ListLogsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListLogsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    async importLogs(
        request: operations.V2ImportLogsRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ImportLogsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/logs/import")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/octet-stream",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ImportLogs",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$ as unknown as BodyInit,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Export logs
     */
    async exportLogs(
        request: operations.V2ExportLogsRequest,
        options?: RequestOptions
    ): Promise<ReadableStream<Uint8Array> | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ExportLogsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/logs/export")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/octet-stream",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ExportLogs",
            oAuth2Scopes: ["auth:read", "ledger:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<ReadableStream<Uint8Array> | undefined>()
            .void(200, z.instanceof(ReadableStream<Uint8Array>).optional())
            .fail(["4XX", "5XX"])
            .stream("default", z.instanceof(ReadableStream<Uint8Array>).optional())
            .match(response);

        return result$;
    }

    /**
     * List exporters
     */
    async listExporters(options?: RequestOptions): Promise<operations.V2ListExportersResponse> {
        const path$ = this.templateURLComponent("/api/ledger/v2/_/exporters")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListExporters",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListExportersResponse>()
            .json(200, operations.V2ListExportersResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListExportersResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create exporter
     */
    async createExporter(
        request: components.V2CreateExporterRequest,
        options?: RequestOptions
    ): Promise<operations.V2CreateExporterResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.V2CreateExporterRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/ledger/v2/_/exporters")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CreateExporter",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2CreateExporterResponse>()
            .json(201, operations.V2CreateExporterResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CreateExporterResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get exporter state
     */
    async getExporterState(
        request: operations.V2GetExporterStateRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetExporterStateResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetExporterStateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            exporterID: encodeSimple$("exporterID", payload$.exporterID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/_/exporters/{exporterID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetExporterState",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetExporterStateResponse>()
            .json(200, operations.V2GetExporterStateResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetExporterStateResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Delete exporter
     */
    async deleteExporter(
        request: operations.V2DeleteExporterRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2DeleteExporterRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            exporterID: encodeSimple$("exporterID", payload$.exporterID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/_/exporters/{exporterID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2DeleteExporter",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * List pipelines
     */
    async listPipelines(
        request: operations.V2ListPipelinesRequest,
        options?: RequestOptions
    ): Promise<operations.V2ListPipelinesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ListPipelinesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/pipelines")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ListPipelines",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2ListPipelinesResponse>()
            .json(200, operations.V2ListPipelinesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2ListPipelinesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create pipeline
     */
    async createPipeline(
        request: operations.V2CreatePipelineRequest,
        options?: RequestOptions
    ): Promise<operations.V2CreatePipelineResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2CreatePipelineRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V2CreatePipelineRequest, { explode: true });

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/pipelines")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2CreatePipeline",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2CreatePipelineResponse>()
            .json(201, operations.V2CreatePipelineResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2CreatePipelineResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get pipeline state
     */
    async getPipelineState(
        request: operations.V2GetPipelineStateRequest,
        options?: RequestOptions
    ): Promise<operations.V2GetPipelineStateResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2GetPipelineStateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
            pipelineID: encodeSimple$("pipelineID", payload$.pipelineID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/pipelines/{pipelineID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2GetPipelineState",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V2GetPipelineStateResponse>()
            .json(200, operations.V2GetPipelineStateResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V2GetPipelineStateResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Delete pipeline
     */
    async deletePipeline(
        request: operations.V2DeletePipelineRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2DeletePipelineRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
            pipelineID: encodeSimple$("pipelineID", payload$.pipelineID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/ledger/v2/{ledger}/pipelines/{pipelineID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2DeletePipeline",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(204, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Reset pipeline
     */
    async resetPipeline(
        request: operations.V2ResetPipelineRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2ResetPipelineRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
            pipelineID: encodeSimple$("pipelineID", payload$.pipelineID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/pipelines/{pipelineID}/reset"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2ResetPipeline",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(202, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Start pipeline
     */
    async startPipeline(
        request: operations.V2StartPipelineRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2StartPipelineRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
            pipelineID: encodeSimple$("pipelineID", payload$.pipelineID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/pipelines/{pipelineID}/start"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2StartPipeline",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(202, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Stop pipeline
     */
    async stopPipeline(
        request: operations.V2StopPipelineRequest,
        options?: RequestOptions
    ): Promise<errors.V2ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V2StopPipelineRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ledger: encodeSimple$("ledger", payload$.ledger, {
                explode: false,
                charEncoding: "percent",
            }),
            pipelineID: encodeSimple$("pipelineID", payload$.pipelineID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/ledger/v2/{ledger}/pipelines/{pipelineID}/stop"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v2StopPipeline",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<errors.V2ErrorResponse | undefined>()
            .void(202, errors.V2ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", errors.V2ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }
}
