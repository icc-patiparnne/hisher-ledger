/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeJSONQuery as encodeJSONQuery$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity } from "../lib/security.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";

export class V3 extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Create a formance account object. This object will not be forwarded to the connector. It is only used for internal purposes.
     *
     */
    async createAccount(
        request?: components.V3CreateAccountRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.V3CreateAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.V3CreateAccountRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/accounts")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreateAccount",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreateAccountResponse>()
            .json(201, operations.V3CreateAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreateAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all accounts
     */
    async listAccounts(
        request: operations.V3ListAccountsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListAccountsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListAccountsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/accounts")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListAccounts",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListAccountsResponse>()
            .json(200, operations.V3ListAccountsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListAccountsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get an account by ID
     */
    async getAccount(
        request: operations.V3GetAccountRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetAccountRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            accountID: encodeSimple$("accountID", payload$.accountID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/accounts/{accountID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetAccount",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetAccountResponse>()
            .json(200, operations.V3GetAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get account balances
     */
    async getAccountBalances(
        request: operations.V3GetAccountBalancesRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetAccountBalancesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetAccountBalancesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            accountID: encodeSimple$("accountID", payload$.accountID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/accounts/{accountID}/balances")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            asset: payload$.asset,
            cursor: payload$.cursor,
            fromTimestamp: payload$.fromTimestamp,
            pageSize: payload$.pageSize,
            toTimestamp: payload$.toTimestamp,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetAccountBalances",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetAccountBalancesResponse>()
            .json(200, operations.V3GetAccountBalancesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetAccountBalancesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create a formance bank account object. This object will not be forwarded to the connector until you called the forwardBankAccount method.
     *
     */
    async createBankAccount(
        request?: components.V3CreateBankAccountRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.V3CreateBankAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                components.V3CreateBankAccountRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/bank-accounts")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreateBankAccount",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreateBankAccountResponse>()
            .json(201, operations.V3CreateBankAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreateBankAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all bank accounts
     */
    async listBankAccounts(
        request: operations.V3ListBankAccountsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListBankAccountsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListBankAccountsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/bank-accounts")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListBankAccounts",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListBankAccountsResponse>()
            .json(200, operations.V3ListBankAccountsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListBankAccountsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a Bank Account by ID
     */
    async getBankAccount(
        request: operations.V3GetBankAccountRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetBankAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetBankAccountRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            bankAccountID: encodeSimple$("bankAccountID", payload$.bankAccountID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/bank-accounts/{bankAccountID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetBankAccount",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetBankAccountResponse>()
            .json(200, operations.V3GetBankAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetBankAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Update a bank account's metadata
     */
    async updateBankAccountMetadata(
        request: operations.V3UpdateBankAccountMetadataRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3UpdateBankAccountMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3UpdateBankAccountMetadataRequest, {
            explode: true,
        });

        const pathParams$ = {
            bankAccountID: encodeSimple$("bankAccountID", payload$.bankAccountID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/bank-accounts/{bankAccountID}/metadata"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3UpdateBankAccountMetadata",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Forward a Bank Account to a PSP for creation
     */
    async forwardBankAccount(
        request: operations.V3ForwardBankAccountRequest,
        options?: RequestOptions
    ): Promise<operations.V3ForwardBankAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ForwardBankAccountRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3ForwardBankAccountRequest, { explode: true });

        const pathParams$ = {
            bankAccountID: encodeSimple$("bankAccountID", payload$.bankAccountID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/bank-accounts/{bankAccountID}/forward"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ForwardBankAccount",
            oAuth2Scopes: ["auth:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ForwardBankAccountResponse>()
            .json(202, operations.V3ForwardBankAccountResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ForwardBankAccountResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all connectors
     */
    async listConnectors(
        request: operations.V3ListConnectorsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListConnectorsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListConnectorsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/connectors")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListConnectors",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListConnectorsResponse>()
            .json(200, operations.V3ListConnectorsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListConnectorsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Install a connector
     */
    async installConnector(
        request: operations.V3InstallConnectorRequest,
        options?: RequestOptions
    ): Promise<operations.V3InstallConnectorResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3InstallConnectorRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3InstallConnectorRequest, { explode: true });

        const pathParams$ = {
            connector: encodeSimple$("connector", payload$.connector, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/install/{connector}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3InstallConnector",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3InstallConnectorResponse>()
            .json(202, operations.V3InstallConnectorResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3InstallConnectorResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all connector configurations
     */
    async listConnectorConfigs(
        options?: RequestOptions
    ): Promise<operations.V3ListConnectorConfigsResponse> {
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/configs")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListConnectorConfigs",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListConnectorConfigsResponse>()
            .json(200, operations.V3ListConnectorConfigsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListConnectorConfigsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Uninstall a connector
     */
    async uninstallConnector(
        request: operations.V3UninstallConnectorRequest,
        options?: RequestOptions
    ): Promise<operations.V3UninstallConnectorResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3UninstallConnectorRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/{connectorID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3UninstallConnector",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3UninstallConnectorResponse>()
            .json(202, operations.V3UninstallConnectorResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3UninstallConnectorResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a connector configuration by ID
     */
    async getConnectorConfig(
        request: operations.V3GetConnectorConfigRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetConnectorConfigResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetConnectorConfigRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/{connectorID}/config")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetConnectorConfig",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetConnectorConfigResponse>()
            .json(200, operations.V3GetConnectorConfigResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetConnectorConfigResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Update the config of a connector
     *
     * @remarks
     * Update connector config
     */
    async v3UpdateConnectorConfig(
        request: operations.V3UpdateConnectorConfigRequest,
        options?: RequestOptions
    ): Promise<components.PaymentsErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3UpdateConnectorConfigRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3UpdateConnectorRequest, { explode: true });

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/{connectorID}/config")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3UpdateConnectorConfig",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.PaymentsErrorResponse | undefined>()
            .void(204, components.PaymentsErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.PaymentsErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Reset a connector. Be aware that this will delete all data and stop all existing tasks like payment initiations and bank account creations.
     */
    async resetConnector(
        request: operations.V3ResetConnectorRequest,
        options?: RequestOptions
    ): Promise<operations.V3ResetConnectorResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ResetConnectorRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/connectors/{connectorID}/reset")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ResetConnector",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ResetConnectorResponse>()
            .json(202, operations.V3ResetConnectorResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ResetConnectorResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all connector schedules
     */
    async listConnectorSchedules(
        request: operations.V3ListConnectorSchedulesRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListConnectorSchedulesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListConnectorSchedulesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/connectors/{connectorID}/schedules"
        )(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListConnectorSchedules",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListConnectorSchedulesResponse>()
            .json(200, operations.V3ListConnectorSchedulesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListConnectorSchedulesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a connector schedule by ID
     */
    async getConnectorSchedule(
        request: operations.V3GetConnectorScheduleRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetConnectorScheduleResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetConnectorScheduleRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            scheduleID: encodeSimple$("scheduleID", payload$.scheduleID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/connectors/{connectorID}/schedules/{scheduleID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetConnectorSchedule",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetConnectorScheduleResponse>()
            .json(200, operations.V3GetConnectorScheduleResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetConnectorScheduleResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all connector schedule instances
     */
    async listConnectorScheduleInstances(
        request: operations.V3ListConnectorScheduleInstancesRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListConnectorScheduleInstancesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3ListConnectorScheduleInstancesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            scheduleID: encodeSimple$("scheduleID", payload$.scheduleID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/connectors/{connectorID}/schedules/{scheduleID}/instances"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            cursor: payload$.cursor,
            pageSize: payload$.pageSize,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListConnectorScheduleInstances",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListConnectorScheduleInstancesResponse>()
            .json(200, operations.V3ListConnectorScheduleInstancesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListConnectorScheduleInstancesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Create a formance payment object. This object will not be forwarded to the connector. It is only used for internal purposes.
     *
     */
    async createPayment(
        request?: components.V3CreatePaymentRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.V3CreatePaymentResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.V3CreatePaymentRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/payments")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreatePayment",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreatePaymentResponse>()
            .json(201, operations.V3CreatePaymentResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreatePaymentResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all payments
     */
    async listPayments(
        request: operations.V3ListPaymentsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPaymentsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListPaymentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/payments")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPayments",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListPaymentsResponse>()
            .json(200, operations.V3ListPaymentsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListPaymentsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a payment by ID
     */
    async getPayment(
        request: operations.V3GetPaymentRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPaymentResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPaymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentID: encodeSimple$("paymentID", payload$.paymentID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/payments/{paymentID}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPayment",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPaymentResponse>()
            .json(200, operations.V3GetPaymentResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPaymentResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Update a payment's metadata
     */
    async updatePaymentMetadata(
        request: operations.V3UpdatePaymentMetadataRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3UpdatePaymentMetadataRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3UpdatePaymentMetadataRequest, {
            explode: true,
        });

        const pathParams$ = {
            paymentID: encodeSimple$("paymentID", payload$.paymentID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/payments/{paymentID}/metadata")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3UpdatePaymentMetadata",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Initiate a payment
     */
    async initiatePayment(
        request: operations.V3InitiatePaymentRequest,
        options?: RequestOptions
    ): Promise<operations.V3InitiatePaymentResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3InitiatePaymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3InitiatePaymentRequest, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/payment-initiations")();

        const query$ = encodeFormQuery$({
            noValidation: payload$.noValidation,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3InitiatePayment",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3InitiatePaymentResponse>()
            .json(202, operations.V3InitiatePaymentResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3InitiatePaymentResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all payment initiations
     */
    async listPaymentInitiations(
        request: operations.V3ListPaymentInitiationsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPaymentInitiationsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListPaymentInitiationsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/payment-initiations")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPaymentInitiations",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListPaymentInitiationsResponse>()
            .json(200, operations.V3ListPaymentInitiationsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListPaymentInitiationsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Delete a payment initiation by ID
     */
    async deletePaymentInitiation(
        request: operations.V3DeletePaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3DeletePaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3DeletePaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Get a payment initiation by ID
     */
    async getPaymentInitiation(
        request: operations.V3GetPaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPaymentInitiationResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPaymentInitiationResponse>()
            .json(200, operations.V3GetPaymentInitiationResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPaymentInitiationResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Retry a payment initiation
     */
    async retryPaymentInitiation(
        request: operations.V3RetryPaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<operations.V3RetryPaymentInitiationResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3RetryPaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/retry"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3RetryPaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3RetryPaymentInitiationResponse>()
            .json(202, operations.V3RetryPaymentInitiationResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3RetryPaymentInitiationResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Approve a payment initiation
     */
    async approvePaymentInitiation(
        request: operations.V3ApprovePaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<operations.V3ApprovePaymentInitiationResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ApprovePaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/approve"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ApprovePaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ApprovePaymentInitiationResponse>()
            .json(202, operations.V3ApprovePaymentInitiationResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ApprovePaymentInitiationResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Reject a payment initiation
     */
    async rejectPaymentInitiation(
        request: operations.V3RejectPaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3RejectPaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/reject"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3RejectPaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Reverse a payment initiation
     */
    async reversePaymentInitiation(
        request: operations.V3ReversePaymentInitiationRequest,
        options?: RequestOptions
    ): Promise<operations.V3ReversePaymentInitiationResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ReversePaymentInitiationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3ReversePaymentInitiationRequest, {
            explode: true,
        });

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/reverse"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ReversePaymentInitiation",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ReversePaymentInitiationResponse>()
            .json(202, operations.V3ReversePaymentInitiationResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ReversePaymentInitiationResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all payment initiation adjustments
     */
    async listPaymentInitiationAdjustments(
        request: operations.V3ListPaymentInitiationAdjustmentsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPaymentInitiationAdjustmentsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3ListPaymentInitiationAdjustmentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/adjustments"
        )(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPaymentInitiationAdjustments",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3ListPaymentInitiationAdjustmentsResponse>()
                .json(200, operations.V3ListPaymentInitiationAdjustmentsResponse$inboundSchema)
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3ListPaymentInitiationAdjustmentsResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * List all payments related to a payment initiation
     */
    async listPaymentInitiationRelatedPayments(
        request: operations.V3ListPaymentInitiationRelatedPaymentsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPaymentInitiationRelatedPaymentsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3ListPaymentInitiationRelatedPaymentsRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentInitiationID: encodeSimple$(
                "paymentInitiationID",
                payload$.paymentInitiationID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-initiations/{paymentInitiationID}/payments"
        )(pathParams$);

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPaymentInitiationRelatedPayments",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3ListPaymentInitiationRelatedPaymentsResponse>()
                .json(200, operations.V3ListPaymentInitiationRelatedPaymentsResponse$inboundSchema)
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3ListPaymentInitiationRelatedPaymentsResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Create a formance payment service user object
     */
    async createPaymentServiceUser(
        request?: components.V3CreatePaymentServiceUserRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.V3CreatePaymentServiceUserResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                components.V3CreatePaymentServiceUserRequest$outboundSchema.optional().parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/payment-service-users")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreatePaymentServiceUser",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreatePaymentServiceUserResponse>()
            .json(201, operations.V3CreatePaymentServiceUserResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreatePaymentServiceUserResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all payment service users
     */
    async listPaymentServiceUsers(
        request: operations.V3ListPaymentServiceUsersRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPaymentServiceUsersResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListPaymentServiceUsersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/payment-service-users")();

        const query$ = encodeFormQuery$({
            cursor: payload$.cursor,
            pageSize: payload$.pageSize,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPaymentServiceUsers",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListPaymentServiceUsersResponse>()
            .json(200, operations.V3ListPaymentServiceUsersResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListPaymentServiceUsersResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a payment service user by ID
     */
    async getPaymentServiceUser(
        request: operations.V3GetPaymentServiceUserRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPaymentServiceUserResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPaymentServiceUserRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPaymentServiceUser",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPaymentServiceUserResponse>()
            .json(200, operations.V3GetPaymentServiceUserResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPaymentServiceUserResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Delete a payment service user by ID
     */
    async deletePaymentServiceUser(
        request: operations.V3DeletePaymentServiceUserRequest,
        options?: RequestOptions
    ): Promise<operations.V3DeletePaymentServiceUserResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3DeletePaymentServiceUserRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3DeletePaymentServiceUser",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3DeletePaymentServiceUserResponse>()
            .json(202, operations.V3DeletePaymentServiceUserResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3DeletePaymentServiceUserResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Remove a payment service user from a connector, the PSU will still exist in Formance
     */
    async deletePaymentServiceUserConnector(
        request: operations.V3DeletePaymentServiceUserConnectorRequest,
        options?: RequestOptions
    ): Promise<operations.V3DeletePaymentServiceUserConnectorResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3DeletePaymentServiceUserConnectorRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3DeletePaymentServiceUserConnector",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3DeletePaymentServiceUserConnectorResponse>()
                .json(202, operations.V3DeletePaymentServiceUserConnectorResponse$inboundSchema)
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3DeletePaymentServiceUserConnectorResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Register/forward a payment service user on/to a connector
     */
    async forwardPaymentServiceUserToProvider(
        request: operations.V3ForwardPaymentServiceUserToProviderRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3ForwardPaymentServiceUserToProviderRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}/forward"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ForwardPaymentServiceUserToProvider",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Create an authentication link for a payment service user on a connector, for oauth flow
     */
    async createLinkForPaymentServiceUser(
        request: operations.V3CreateLinkForPaymentServiceUserRequest,
        options?: RequestOptions
    ): Promise<operations.V3CreateLinkForPaymentServiceUserResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3CreateLinkForPaymentServiceUserRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3PaymentServiceUserCreateLinkRequest, {
            explode: true,
        });

        const pathParams$ = {
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}/create-link"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreateLinkForPaymentServiceUser",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreateLinkForPaymentServiceUserResponse>()
            .json(201, operations.V3CreateLinkForPaymentServiceUserResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreateLinkForPaymentServiceUserResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a link attempt for a payment service user on a connector
     */
    async getPaymentServiceUserLinkAttemptFromConnectorID(
        request: operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            attemptID: encodeSimple$("attemptID", payload$.attemptID, {
                explode: false,
                charEncoding: "percent",
            }),
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}/link-attempts/{attemptID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPaymentServiceUserLinkAttemptFromConnectorID",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDResponse>()
                .json(
                    200,
                    operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDResponse$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3GetPaymentServiceUserLinkAttemptFromConnectorIDResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Delete a connection for a payment service user on a connector
     */
    async deletePaymentServiceUserConnectionFromConnectorID(
        request: operations.V3DeletePaymentServiceUserConnectionFromConnectorIDRequest,
        options?: RequestOptions
    ): Promise<operations.V3DeletePaymentServiceUserConnectionFromConnectorIDResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3DeletePaymentServiceUserConnectionFromConnectorIDRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connectionID: encodeSimple$("connectionID", payload$.connectionID, {
                explode: false,
                charEncoding: "percent",
            }),
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}/connections/{connectionID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3DeletePaymentServiceUserConnectionFromConnectorID",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3DeletePaymentServiceUserConnectionFromConnectorIDResponse>()
                .json(
                    202,
                    operations.V3DeletePaymentServiceUserConnectionFromConnectorIDResponse$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3DeletePaymentServiceUserConnectionFromConnectorIDResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Update/Regenerate a link for a payment service user on a connector
     */
    async updateLinkForPaymentServiceUserOnConnector(
        request: operations.V3UpdateLinkForPaymentServiceUserOnConnectorRequest,
        options?: RequestOptions
    ): Promise<operations.V3UpdateLinkForPaymentServiceUserOnConnectorResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3UpdateLinkForPaymentServiceUserOnConnectorRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3PaymentServiceUserUpdateLinkRequest, {
            explode: true,
        });

        const pathParams$ = {
            connectionID: encodeSimple$("connectionID", payload$.connectionID, {
                explode: false,
                charEncoding: "percent",
            }),
            connectorID: encodeSimple$("connectorID", payload$.connectorID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/connectors/{connectorID}/connections/{connectionID}/update-link"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3UpdateLinkForPaymentServiceUserOnConnector",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3UpdateLinkForPaymentServiceUserOnConnectorResponse>()
                .json(
                    201,
                    operations.V3UpdateLinkForPaymentServiceUserOnConnectorResponse$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3UpdateLinkForPaymentServiceUserOnConnectorResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Add a bank account to a payment service user
     */
    async addBankAccountToPaymentServiceUser(
        request: operations.V3AddBankAccountToPaymentServiceUserRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3AddBankAccountToPaymentServiceUserRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            bankAccountID: encodeSimple$("bankAccountID", payload$.bankAccountID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/bank-accounts/{bankAccountID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3AddBankAccountToPaymentServiceUser",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Forward a payment service user's bank account to a connector
     */
    async forwardPaymentServiceUserBankAccount(
        request: operations.V3ForwardPaymentServiceUserBankAccountRequest,
        options?: RequestOptions
    ): Promise<operations.V3ForwardPaymentServiceUserBankAccountResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.V3ForwardPaymentServiceUserBankAccountRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.V3ForwardPaymentServiceUserBankAccountRequest, {
            explode: true,
        });

        const pathParams$ = {
            bankAccountID: encodeSimple$("bankAccountID", payload$.bankAccountID, {
                explode: false,
                charEncoding: "percent",
            }),
            paymentServiceUserID: encodeSimple$(
                "paymentServiceUserID",
                payload$.paymentServiceUserID,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/payment-service-users/{paymentServiceUserID}/bank-accounts/{bankAccountID}/forward"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ForwardPaymentServiceUserBankAccount",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.V3ForwardPaymentServiceUserBankAccountResponse>()
                .json(202, operations.V3ForwardPaymentServiceUserBankAccountResponse$inboundSchema)
                .fail(["4XX", "5XX"])
                .json(
                    "default",
                    operations.V3ForwardPaymentServiceUserBankAccountResponse$inboundSchema
                )
                .match(response);

        return result$;
    }

    /**
     * Create a formance pool object
     */
    async createPool(
        request?: components.V3CreatePoolRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.V3CreatePoolResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.V3CreatePoolRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/api/payments/v3/pools")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3CreatePool",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3CreatePoolResponse>()
            .json(201, operations.V3CreatePoolResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3CreatePoolResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * List all pools
     */
    async listPools(
        request: operations.V3ListPoolsRequest,
        options?: RequestOptions
    ): Promise<operations.V3ListPoolsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3ListPoolsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/api/payments/v3/pools")();

        const query$ = queryJoin$(
            encodeFormQuery$({
                cursor: payload$.cursor,
                pageSize: payload$.pageSize,
            }),
            encodeJSONQuery$(
                {
                    query: payload$.query,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3ListPools",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3ListPoolsResponse>()
            .json(200, operations.V3ListPoolsResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3ListPoolsResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get a pool by ID
     */
    async getPool(
        request: operations.V3GetPoolRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPoolResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPoolRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/pools/{poolID}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPool",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPoolResponse>()
            .json(200, operations.V3GetPoolResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPoolResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Delete a pool by ID
     */
    async deletePool(
        request: operations.V3DeletePoolRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3DeletePoolRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/pools/{poolID}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3DeletePool",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Get historical pool balances from a particular point in time
     */
    async getPoolBalances(
        request: operations.V3GetPoolBalancesRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPoolBalancesResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPoolBalancesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/pools/{poolID}/balances")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            at: payload$.at,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPoolBalances",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPoolBalancesResponse>()
            .json(200, operations.V3GetPoolBalancesResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPoolBalancesResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Get latest pool balances
     */
    async getPoolBalancesLatest(
        request: operations.V3GetPoolBalancesLatestRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetPoolBalancesLatestResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetPoolBalancesLatestRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/pools/{poolID}/balances/latest")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetPoolBalancesLatest",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetPoolBalancesLatestResponse>()
            .json(200, operations.V3GetPoolBalancesLatestResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetPoolBalancesLatestResponse$inboundSchema)
            .match(response);

        return result$;
    }

    /**
     * Add an account to a pool
     */
    async addAccountToPool(
        request: operations.V3AddAccountToPoolRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3AddAccountToPoolRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            accountID: encodeSimple$("accountID", payload$.accountID, {
                explode: false,
                charEncoding: "percent",
            }),
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/pools/{poolID}/accounts/{accountID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3AddAccountToPool",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Remove an account from a pool
     */
    async removeAccountFromPool(
        request: operations.V3RemoveAccountFromPoolRequest,
        options?: RequestOptions
    ): Promise<components.V3ErrorResponse | undefined> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3RemoveAccountFromPoolRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            accountID: encodeSimple$("accountID", payload$.accountID, {
                explode: false,
                charEncoding: "percent",
            }),
            poolID: encodeSimple$("poolID", payload$.poolID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/api/payments/v3/pools/{poolID}/accounts/{accountID}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3RemoveAccountFromPool",
            oAuth2Scopes: ["auth:read", "payments:write"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<components.V3ErrorResponse | undefined>()
            .void(204, components.V3ErrorResponse$inboundSchema.optional())
            .fail(["4XX", "5XX"])
            .json("default", components.V3ErrorResponse$inboundSchema.optional())
            .match(response);

        return result$;
    }

    /**
     * Get a task and its result by ID
     */
    async getTask(
        request: operations.V3GetTaskRequest,
        options?: RequestOptions
    ): Promise<operations.V3GetTaskResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.V3GetTaskRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            taskID: encodeSimple$("taskID", payload$.taskID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/api/payments/v3/tasks/{taskID}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "v3GetTask",
            oAuth2Scopes: ["auth:read", "payments:read"],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.V3GetTaskResponse>()
            .json(200, operations.V3GetTaskResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .json("default", operations.V3GetTaskResponse$inboundSchema)
            .match(response);

        return result$;
    }
}
